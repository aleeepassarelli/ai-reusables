# -----------------------------------------------------------------
# üß© Atomic Architecture: Cadeia Sem√¢ntica (Mol√©cula)
# molecules/proc_matricula_001.yaml
# -----------------------------------------------------------------
#
# CADEIA ID: proc_matricula_001
# DESCRI√á√ÉO: Caso de Uso da Escola. Processa um formul√°rio de matr√≠cula
#            escaneado (PDF/Imagem), extrai, valida e salva os dados.
#
# -----------------------------------------------------------------

chain_id: "proc_matricula_001"
description: "Fluxo de processamento de formul√°rios de matr√≠cula escaneados."

# --- Gatilho (Input) ---
# Define como esta cadeia √© iniciada.
input_trigger:
  source: "web_interface"
  action: "file_upload"
  # O payload de entrada esperado. Ex: { "file_path": "/tmp/doc.pdf" }
  params:
    - "file_path"

# -----------------------------------------------------------------
# --- Esqueleto (Skeleton-of-Thought) ---
# (Baseado no sot_framework.md - N√≠vel 4: Estabilidade)
# -----------------------------------------------------------------
sot:
  id: "matricula_pipeline"
  goal: "Processar formul√°rios de matr√≠cula."
  context: "PDFs ou imagens digitalizadas enviadas pela secretaria."
  
  # O 'esqueleto' define a estrutura l√≥gica que o 'steps' (passos)
  # abaixo deve seguir.
  skeleton:
    - "leitura_OCR"
    - "extracao_campos"
    - "validacao_dados"
    - "gravacao_banco"
    - "relatorio_final"

# -----------------------------------------------------------------
# --- Passos de Execu√ß√£o (Implementa√ß√£o do Esqueleto) ---
# O AtomicEngine executa esta lista em ordem.
# -----------------------------------------------------------------
steps:
  
  # --- Passo 1: Leitura OCR ---
  - step: 1
    name: "leitura_OCR"
    description: "Usa o agente OCR sem√¢ntico para ler o arquivo."
    agent: "agent_OCR.yaml" # (Organismo)
    
    # Mapeia o 'file_path' do gatilho para a entrada do agente
    input: "$.input_trigger.file_path"
    
    # O resultado √© salvo no contexto
    output_variable: "raw_markdown_content"

  # --- Passo 2: Extra√ß√£o de Campos ---
  - step: 2
    name: "extracao_campos"
    description: "Usa o agente de estrutura√ß√£o para extrair entidades do texto."
    agent: "agent_text_struct.yaml" # (Organismo)
    
    # Usa a sa√≠da do passo anterior como entrada
    input: "$.steps[0].raw_markdown_content"
    
    # O 'prompt' sem√¢ntico que guia o agente de extra√ß√£o (N√≠vel 4)
    prompt: |
      Analise o texto da ficha de matr√≠cula e extraia as seguintes
      informa√ß√µes em formato JSON:
      - 'nome_aluno': (String) Nome completo do aluno.
      - 'cpf_aluno': (String) CPF do aluno, formatado (XXX.XXX.XXX-XX).
      - 'data_nascimento': (String) Data de nascimento (AAAA-MM-DD).
      - 'nome_responsavel': (String) Nome completo do respons√°vel.
      - 'cpf_responsavel': (String) CPF do respons√°vel.
      - 'telefone_contato': (String) Telefone com DDD.

    output_variable: "structured_json_data"

  # --- Passo 3: Valida√ß√£o de Dados ---
  - step: 3
    name: "validacao_dados"
    description: "Usa um agente assistente para validar os dados extra√≠dos (N√≠vel 5: Rigor)."
    agent: "agent_assistant.yaml" # (Organismo - Mistral)
    
    # Usa a sa√≠da JSON do Passo 2 como entrada
    input: "$.steps[1].structured_json_data"
    
    prompt: |
      Analise o JSON. O 'cpf_aluno' √© v√°lido? O 'data_nascimento' √© uma data real?
      Responda APENAS em formato JSON:
      {
        "is_valid": true/false,
        "errors": ["(lista de erros, se houver)"]
      }
    
    output_variable: "validation_report"

  # --- Passo 4: Grava√ß√£o no Banco ---
  - step: 4
    name: "gravacao_banco"
    description: "Usa o agente MCP para salvar os dados no Grafo (Camada 1)."
    agent: "agent_mcp.yaml" # (Organismo - Jan v1-4B)
    
    # O input para a ferramenta 'save_to_graph_db'
    # (Note: O input vem do Passo 2, os dados validados)
    input:
      data: "$.steps[1].structured_json_data"
      # Par√¢metros que dizem √† 'api_mcp' como salvar.
      params:
        target_db: "graphiti_neo4j"
        entity_type: "Aluno"
        primary_key: "cpf_aluno"
        
    output_variable: "db_save_status" # Ex: { "status": "success", "node_id": "..." }

  # --- Passo 5: Relat√≥rio Final ---
  - step: 5
    name: "relatorio_final"
    description: "Gera um resumo da opera√ß√£o para o usu√°rio."
    agent: "agent_assistant.yaml" # (Organismo - Mistral)
    
    input:
      - "$.steps[1].structured_json_data.nome_aluno"
      - "$.steps[3].db_save_status.status"
    
    prompt: |
      O aluno '{{ input[0] }}' foi processado com status '{{ input[1] }}'.
      Escreva um resumo de 1 linha sobre esta opera√ß√£o.
    
    output_variable: "summary_text"

# -----------------------------------------------------------------
# --- Relat√≥rio de Sa√≠da (Para Camada 4/5) ---
# O AtomicEngine usa isso para formatar a resposta final.
# -----------------------------------------------------------------
output_report:
  deliver_to: "web_interface"
  
  # Usa o template da Camada 4
  template: "report_template.md"
  
  # Mapeia os dados do contexto para os placeholders do template
  data:
    chain_id: "proc_matricula_001"
    status: "$.steps[3].db_save_status.status"
    timestamp: "CURRENT_TIMESTAMP" # O engine deve substituir isso
    summary: "$.steps[4].summary_text.raw_text"
    data: "$.steps[1].structured_json_data"
    node_id: "$.steps[3].db_save_status.node_id"
